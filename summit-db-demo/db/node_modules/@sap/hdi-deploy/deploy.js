'use strict';

/* jslint indent: 4 */

var logger = require('./lib/logger.js');
logger.timerInit('overall');

var fs = require('fs');
var utils = require('./lib/utils.js');

// if a default-env.json file exists, integrate the contained variables into process.env
var xsenv = require('@sap/xsenv');
var defaultEnvFile = 'default-env.json';
var usedDefaultEnvFile = false;
if (fs.existsSync(defaultEnvFile)) {
    xsenv.loadEnv(defaultEnvFile);
    // we write the log message later
    usedDefaultEnvFile = true;
}

// variables for the default-services.json file
var defaultServicesFile = 'default-services.json';
var usedDefaultServicesFile = false;

var pjson = require('./package.json');
var options = require('./lib/options.js');
var args = require('./lib/arguments.js');

var opt = options();

var exit_rc0_silent = Error('');

function idle() {
    setTimeout(idle, 10 * 60 * 1000);
}

function signalProcessExit(exitCode, showOverallTime, forcedExit) {
    if (showOverallTime) {
        logger.log(logger.timerDelta('overall'));
    }

    if (opt.exit || exitCode || forcedExit) {
        var written = process.stdout.write("\n");
        if (written) {
            // stdout was already drained, just exit now
            process.exit(exitCode);
        } else {
            // register for drain event, and idle until then
            process.stdout.once('drain', function() {
                process.exit(exitCode);
            });
            // fall through to idle()
        }
    } else {
        logger.log('Application can be stopped.');
        // fall through to idle()
    }

    // always idle() if we get here
    idle();

    // note: returning to caller here, idle() is handled in the event loop
}

// set defaults from environment variables
if (typeof process.env.EXIT !== "undefined") {
    opt.exit = true;
}

// check environment variable HDI_DEPLOY_OPTIONS for more options and translate them to process arguments
if (typeof process.env.HDI_DEPLOY_OPTIONS !== "undefined") {
    var options;
    var name = 'HDI_DEPLOY_OPTIONS';
    try {
        options = JSON.parse(process.env[name]);
    } catch (error) {
        logger.error('Failed to parse JSON object in HDI_DEPLOY_OPTIONS: ' + error);
        process.exit(1);
    }

    for (var option in options) {
        if (option === 'auto_undeploy') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'exit') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'detect_server_version') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'lock_container') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'working_set') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'include_filter') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'deploy') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'undeploy') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'parameter') {
            args.translateJSONEnvStringKeyValueObjectOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'treat_warnings_as_errors') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'simulate_make') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'info') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'root') {
            args.translateJSONEnvStringOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'structured_log') {
            args.translateJSONEnvStringOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'verbose') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'strip_cr_from_csv') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'connection_timeout') {
            args.translateJSONEnvIntegerOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'lock_container_timeout') {
            args.translateJSONEnvIntegerOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'send_messages_to_parent_process') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else {
            logger.error('Unknown option ' + option + ' in HDI_DEPLOY_OPTIONS');
            process.exit(1);
        }
    }
}

// some check functions (to avoid to create functions in loops)
function checkPathInDeployOption(path) {
    if (path[path.length - 1] === '/') {
        logger.error('Error: option deploy does not support directories: ' + path);
        process.exit(1);
    }
}
function checkPathInUndeployOption(path) {
    if (path[path.length - 1] === '/') {
        logger.error('Error: option undeploy does not support directories: ' + path);
        process.exit(1);
    }
}

// process arguments
var showInfo = false;
var showInfoComponents = [];
for (var i = 2; i < process.argv.length; ++i) {
    var arg = process.argv[i];
    if (arg === '-h' || arg === '--help') {
        var help = [
            "",
            "  " + pjson.name + ", version " + pjson.version,
            "",
            "  Options:",
            "",
            "    -h, --help                    print usage information and exit",
            "        --version                 print version and exit",
            "    -t, --trace                   enable tracing",
            "        --[no-]verbose            [don't] print detailed log messages to the console",
            "        --structured-log <file>   write log messages as JSON objects into the given file; messages are appended if the file already exists",
            "",
            "        --info [<component> ..]   show information about the given components and exit; available components: all, client, server",
            "                                  by default, information about all components will be shown",
            "        --[no-]detect-server-version",
            "                                  [don't] detect the version of the server",
            "                                  by default, version detection is enabled",
            "",
            "        --[no-]exit               [don't] exit after deployment of artifacts",
            "                                  by default, the application will not exit, but enter an idle mode",
            "        --[no-]lock-container     [don't] acquire the container lock while working with the container",
            "                                  by default, the container is locked for server versions >= 2.0.10.0",
            "",
            "        --root <path>             use the given root path for artifacts",
            "                                  by default, the current work directory is used",
            "        --working-set [<path> ..]",
            "                                  define the given paths (directories and files) as the working set; use -- as a separator if a path starts with --",
            "                                  by default, the default working set is used",
            "                                  a non-default working set applies additional restrictions, e.g. other options might be disallowed",
            "        --include-filter [<path> ..]",
            "                                  only include the given paths (directories and files) during delta detection; use -- as a separator if a path starts with --",
            "                                  by default, no / an empty filter is used",
            "        --deploy [<file> ..]      explicitly schedule the given files for deploy; extends the include-filter for collecting local files",
            "        --undeploy [<file> ..]    explicitly schedule the given files for undeploy",
            "        --[no-]auto-undeploy      [don't] undeploy artifacts automatically based on delta detection and ignore the undeploy.json file",
            "                                  by default, artifacts will not be undeployed automatically",
            "",
            "        --[no-]treat-warnings-as-errors",
            "                                  [don't] treat warnings as errors",
            "        --[no-]simulate-make      [don't] simulate the make and skip post-make activities; pre-make activities still take effect, e.g. grants",
            "        --parameter [<key>=<value> ..]",
            "                                  pass the given list of key-value parameters to the deployment",
            "",
            "        --[no-]strip-cr-from-csv  [don't] strip carriage return characters from CSV files",
            "                                  by default, CSV files are not modified",
            "",
            "        --connection-timeout <ms>",
            "                                  number of milliseconds to wait for the database connection(s)",
            "                                  by default, the timeout is " + opt.connectionTimeout + " ms",
            "        --lock-container-timeout <ms>",
            "                                  number of milliseconds to wait for the container lock",
            "                                  by default, the timeout is " + opt.lockContainerTimeout + " ms",
            ""
        ];
        logger.log(help.join("\n"));
        signalProcessExit(0, false, true);
        return;
    } else if (arg === '--version') {
        logger.log(pjson.version);
        signalProcessExit(0, false, true);
        return;
    } else if (arg === '--info') {
        // just collect the components here to ensure that the last occurrence of the option wins
        showInfo = true;
        i = args.translateStringListOptionToArray(i, process.argv, showInfoComponents);
    } else if (arg === '-a' || arg === '--autoUndeploy') {
        opt.autoUndeploy = true;
    } else if (arg === '--auto-undeploy') {
        opt.autoUndeploy = true;
    } else if (arg === '--no-auto-undeploy') {
        opt.autoUndeploy = false;
    } else if (arg === '--exit') {
        opt.exit = true;
    } else if (arg === '--no-exit') {
        opt.exit = false;
    } else if (arg === '--detect-server-version') {
        opt.detectServerVersion = true;
    } else if (arg === '--no-detect-server-version') {
        opt.detectServerVersion = false;
    } else if (arg === '--lock-container') {
        opt.lockContainer = true;
    } else if (arg === '--no-lock-container') {
        opt.lockContainer = false;
    } else if (arg === '--working-set') {
        i = args.translatePathListOptionToPathFilter(i, process.argv, opt.workingSet);
    } else if (arg === '--include-filter') {
        i = args.translatePathListOptionToPathFilter(i, process.argv, opt.includeFilter);
    } else if (arg === '--deploy') {
        i = args.translatePathListOptionToPathFilter(i, process.argv, opt.deploy, checkPathInDeployOption);
    } else if (arg === '--undeploy') {
        i = args.translatePathListOptionToPathFilter(i, process.argv, opt.undeploy, checkPathInUndeployOption);
    } else if (arg === '--parameter') {
        i = args.translateStringKeyValueListOptionToObject(i, process.argv, opt.parameters);
    } else if (arg === '--treat-warnings-as-errors') {
        opt.treatWarningsAsErrors = true;
    } else if (arg === '--no-treat-warnings-as-errors') {
        opt.treatWarningsAsErrors = false;
    } else if (arg === '--simulate-make') {
        opt.simulateMake = true;
    } else if (arg === '--no-simulate-make') {
        opt.simulateMake = false;
    } else if (arg === '--root') {
        ++i;
        if (i >= process.argv.length) {
            logger.error('Option root requires a <path> argument');
            process.exit(1);
        }
        opt.root = process.argv[i];
    } else if (arg === '--structured-log') {
        ++i;
        if (i >= process.argv.length) {
            logger.error('Option structured-log requires a <file> argument');
            process.exit(1);
        }
        opt.logFile = process.argv[i];
    } else if (arg === '--send-messages-to-parent-process') {
        opt.sendMessagesToParentProcess = true;
    } else if (arg === '--no-send-messages-to-parent-process') {
        opt.sendMessagesToParentProcess = false;
    } else if (arg === '--verbose') {
        opt.verbose = true;
    } else if (arg === '--no-verbose') {
        opt.verbose = false;
    } else if (arg === '--strip-cr-from-csv') {
        opt.stripCRFromCSV = true;
    } else if (arg === '--no-strip-cr-from-csv') {
        opt.stripCRFromCSV = false;
    } else if (arg === '-t' || arg === '--trace') {
        logger.setTrace(true);
    } else if (arg === '--connection-timeout') {
        ++i;
        if (i >= process.argv.length || '' + Number.parseInt(process.argv[i]) !== '' + process.argv[i]) {
            logger.error('Option connection-timeout requires an integer argument');
            process.exit(1);
        }
        opt.connectionTimeout = Number.parseInt(process.argv[i]);
    } else if (arg === '--lock-container-timeout') {
        ++i;
        if (i >= process.argv.length || '' + Number.parseInt(process.argv[i]) !== '' + process.argv[i]) {
            logger.error('Option lock-container-timeout requires an integer argument');
            process.exit(1);
        }
        opt.lockContainerTimeout = Number.parseInt(process.argv[i]);
    } else {
        logger.error('Unknown argument: ' + arg);
        process.exit(1);
    }
}

// check for valid HDI_DEPLOY_MODE values
if (typeof process.env.HDI_DEPLOY_MODE !== "undefined") {
    var mode = process.env.HDI_DEPLOY_MODE;
    if (mode === 'ZDM') {
        // ok
    } else if (mode === '') {
        // ok, will be treated as default
    } else{
        logger.error('Unknown value for HDI_DEPLOY_MODE: ' + mode);
        process.exit(1);
    }
}

// trace the options object after processing the arguments
logger.trace('options:', opt);
logger.trace('HDI_DEPLOY_MODE: "' + process.env.HDI_DEPLOY_MODE + '"');

// argument processing is complete

// apply the logger specific options
logger.setVerbose(opt.verbose);
logger.setLogFile(opt.logFile);
logger.setSendMessagesToParentProcess(opt.sendMessagesToParentProcess); // only used for inter process communication when forked from server.js

var async = require('async');
var services;
var version_server = require('./lib/version.server.js');
var serverVersion = version_server.getFallbackVersion();
var info = {};

function handleShowInfoOptionAndExit(cb) {
    try {
        // fill info object
        info = require('./lib/info.js').getInfoForComponents(showInfoComponents, serverVersion);

        // show info and stop; if requested
        if (showInfo) {
            logger.log(JSON.stringify(info, null, 4));
            cb(exit_rc0_silent);
            return;
        }

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function injectDefaultServices(cb) {
    try {
        // if a default-services.json file exists, integrate the contained services into process.env.VCAP_SERVICES
        if (fs.existsSync(defaultServicesFile)) {
            var defaultServices = utils.readJSONFile(defaultServicesFile);

            // get current env.VCAP_SERVICES
            var vcapServices = {};
            if ('VCAP_SERVICES' in process.env) {
                try {
                    vcapServices = JSON.parse(process.env.VCAP_SERVICES);
                } catch (error) {
                    cb('Could not parse VCAP_SERVICES environment variable: ' + error);
                }
            }

            // integrate all default services which do not exist in env.VCAP_SERVICES
            for (var defaultService in defaultServices) {
                if (defaultServices.hasOwnProperty(defaultService)) {
                    if (!(defaultService in vcapServices)) {
                        vcapServices[defaultService] = defaultServices[defaultService];
                    }
                }
            }

            // update env.VCAP_SERVICES
            process.env.VCAP_SERVICES = JSON.stringify(vcapServices, null, 1);

            usedDefaultServicesFile = true;
        }

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function initializeServices(cb) {
    try {
        // read services and service replacements
        services = require('./lib/services.js')();

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function initializeServerVersion(cb) {
    try {
        if (opt.detectServerVersion) {
            version_server.getVersion(services.getTargetCreds(), function(err, result) {
                serverVersion = result;
                cb();
            });
        } else {
            cb();
        }
    } catch (error) {
        cb(error.message);
    }
}

function showVersionAndOtherInformation(cb) {
    try {
        // always show our name plus version number; for support cases
        var mode = process.env.HDI_DEPLOY_MODE ? ('' + process.env.HDI_DEPLOY_MODE).toLowerCase() : 'default';
        logger.log(pjson.name + ', version ' + pjson.version + ' (mode ' + mode + '), server version ' + serverVersion.version + ' (' + serverVersion.versionSynthesized + '), node version ' + process.versions.node);

        // log that we couldn't get the version from the server (usually we don't have privileges for SYS.M_DATABASE)
        if (serverVersion.error) {
            logger.log('Detection of server version failed; root cause: ' + serverVersion.error);
        }

        // if a default-env.json was sourced, write the log message now
        if (usedDefaultEnvFile) {
            logger.log('Using default environment variables from file "' + defaultEnvFile + '"');
        }

        if (usedDefaultServicesFile) {
            logger.log('Using default services from file "' + defaultServicesFile + '"');
        }

        if (services.usingServiceReplacements()) {
            logger.log('Using service replacements from environment variable "SERVICE_REPLACEMENTS" with ' + Object.getOwnPropertyNames(services.getServiceReplacements()).length + ' replacements');
        }

        if (opt.workingSet.valid) {
            logger.log('Using a non-default working set with ' + opt.workingSet.size() + ' paths');
        }

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function setInternalOptionsBasedOnServerVersion(cb) {
    if (serverVersion.isGreaterThanOrEqualTo(1, 0, 120, 0)) {
        // since 1.0.120, we can use ignore_non_existing_paths on the server-side
        opt.singleDeleteCallsForDirectories = false;
    }

    if (opt.lockContainer === undefined) {
        // since 2.0.10.0, we automatically use the container-level LOCK API on the server-side if nothing was defined explicitly
        opt.lockContainer = serverVersion.isGreaterThanOrEqualTo(2, 0, 10, 0);
    }

    cb();
}

function checkArgumentsAgainstFeatures(cb) {
    if (Object.keys(opt.parameters).length !== 0) {
        if (info.client.features.parameter <= 0) {
            cb('Option parameter is not supported by the server; based on detected server version ' + serverVersion.version);
        }
    }

    if (opt.simulateMake) {
        if (info.client.features['simulate-make'] <= 0) {
            cb('Option simulate-make is not supported by the server; based on detected server version ' + serverVersion.version);
        }
    }

    if (opt.treatWarningsAsErrors) {
        if (info.client.features['treat-warnings-as-errors'] <= 0) {
            cb('Option treat-warnings-as-errors is not supported by the server; based on detected server version ' + serverVersion.version);
        }
    }

    if (opt.lockContainer) {
        if (info.client.features['lock-container'] <= 0) {
            cb('Option lock-container is not supported by the server; based on detected server version ' + serverVersion.version);
        }
    }

    if (process.env.HDI_DEPLOY_MODE === 'ZDM') {
        if (info.client.features['zero-downtime-update'] <= 0) {
            cb('Zero-downtime update is not supported by the server; based on detected server version ' + serverVersion.version);
        }
    }

    cb();
}

function checkArgumentsForWorkingSet(cb) {
    if (opt.workingSet.valid) {
        opt.deploy.forEachFile(function(file) {
            if (!opt.workingSet.matchesPath(file)) {
                cb('Explicit deploy of file "' + file + '" is not allowed; the file is not in the working set');
            }
        });

        opt.undeploy.forEachFile(function(file) {
            if (!opt.workingSet.matchesPath(file)) {
                cb('Explicit undeploy of file "' + file + '" is not allowed; the file is not in the working set');
            }
        });

        opt.includeFilter.forEachFile(function(file) {
            if (!opt.workingSet.matchesPath(file)) {
                cb('Explicit delta detection of file "' + file + '" is not allowed; the file is not in the working set');
            }
        });
    }

    cb();
}

function processFilesAndDeploy(cb) {
    try {
        // finally, do the dirty work
        var deploy = require('./lib/deploy.js');
        deploy(opt, services, cb);
    } catch (error) {
        cb(error.message);
    }
}

function sendFinalMessageToParentProcess(cb) {
    var timeout;
    var waitingForResponseFromParent = true;

    function attemptToSendFinalMessage(attempt) {
        if (attempt >= 5) {
            waitingForResponseFromParent = false;
            // after 5 attempts to send final message without response quit anyway.
            cb('could not send final message or got no response from parent process');
            return;
        }

        process.send({final_message_sent:{}}, function(err) {
            if (err) {
                var msg;
                if (err.message) {
                    msg = err.message;
                } else {
                    msg = err;
                }
                logger.error('could not send final message to parent process: ' + msg + '\n  trying again in one second...');
            }
            timeout = setTimeout(attemptToSendFinalMessage, 1000, attempt+1);
        });
    }

    if (opt.sendMessagesToParentProcess)
    {
        if (!process.send) {
            cb('could not send message to parent process due to missing process.send');
            return;
        }

        // by sending two final messages (to the parent and back) we ensure
        // that all messages were received before exiting the deployer
        process.on('message', function(message) {
            if (message.hasOwnProperty('final_message_received'))
            {
                if (waitingForResponseFromParent) {
                    waitingForResponseFromParent = false;
                    clearTimeout(timeout);
                    cb();
                }
            }
        });

        attemptToSendFinalMessage(0);
    } else {
        cb();
    }
}

var tasks = [
    injectDefaultServices,
    initializeServices,
    initializeServerVersion,
    handleShowInfoOptionAndExit,
    showVersionAndOtherInformation,
    setInternalOptionsBasedOnServerVersion,
    checkArgumentsAgainstFeatures,
    checkArgumentsForWorkingSet,
    processFilesAndDeploy,
    sendFinalMessageToParentProcess
];

async.series(tasks, function(err) {
    if (err === exit_rc0_silent) {
        signalProcessExit(0, false, true);
    } else {
        if (err) {
            if (err.message) {
                logger.error('Error: ' + err.message);
            } else {
                logger.error('Error: ' + err);
            }
        }
        signalProcessExit(err ? 1 : 0, true);
    }
});
