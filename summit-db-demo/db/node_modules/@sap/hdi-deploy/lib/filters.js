'use strict';

var util = require('util');

/* jslint indent: 4 */

// A filter for paths (directories and files)
function PathFilter() {

    // inspect will be called by util.inspect in node.js
    // we want to avoid that the 'class name' is also printed and mucks up the assertions
    this.inspect = function() {
        return util.format('{ valid: %s, directories: %j, files: %j }', this.valid, this.directories, this.files);
        /*
        var dirs = '';
        Object.keys(this.directories).forEach(function(dir) {
            if (dirs.length === 0) {
                dirs += ' \'' + dir + '\': ' + this.directories[dir];
            } else {
                dirs += ', \'' + dir + '\': ' + this.directories[dir];
            }
        });

        var files = '';
        Object.keys(this.files).forEach(function(file) {
            if (files.length === 0) {
                files += ' \'' + file + '\': ' + this.files[file];
            } else {
                files += ', \'' + file + '\': ' + this.files[file];
            }
        });

        return util.format('{ valid: %s, directories: {%s}, files: {%s} }', this.valid, dirs, files);
        */
    };

    // adds the given path and makes the filter valid
    this.addPath = function(path) {
        this.valid = true;
        if (path[path.length - 1] === '/') {
            this.directories[path] = true;
        } else {
            this.files[path] = true;
        }
    };

    // adds the given paths and makes the filter valid
    this.addPaths = function(paths) {
        if (Array.isArray(paths)) {
            for (var i = 0; i < paths.length; ++i) {
                this.addPath(paths[i]);
            }
        } else {
            var ps;
            var p;
            if (paths.hasOwnProperty('directories')) {
                ps = paths.directories;
                for (p in ps) {
                    if (ps.hasOwnProperty(p)) {
                        this.addPath(p);
                    }
                }
            }
            if (paths.hasOwnProperty('files')) {
                ps = paths.files;
                for (p in ps) {
                    if (ps.hasOwnProperty(p)) {
                        this.addPath(p);
                    }
                }
            }
        }
    };

    // checks whether the given path (directory or file) matches to the filter
    this.matchesPath = function(path) {
        if (!this.valid) {
            // an invalid filter always contains everything
            return true;
        }

        if (this.files.hasOwnProperty(path)) {
            // exact match for a file
            return true;
        }

        for (var directory in this.directories) {
            if (path.indexOf(directory) === 0) { // startsWith
                // we have a directory in the filter which is a prefix of path
                return true;
            }
        }

        return false;
    };

    // calls the given callback for each file in this filter
    this.forEachFile =  function(cb) {
        if (!this.valid) {
            return;
        }

        for (var path in this.files) {
            if (this.files.hasOwnProperty(path)) {
                cb(path);
            }
        }
    };

    // returns the number of elements in the filter
    this.size = function() {
        return Object.keys(this.directories).length + Object.keys(this.files).length;
    };

    // invalidates this filter
    this.invalidate = function() {
        this.valid = false;
        this.directories = {};
        this.files = {};
    };

    this.invalidate();
}

// creates a new, invald path filter
function invalidPathFilter() {
    return new PathFilter();
}

module.exports = {
    invalidPathFilter: invalidPathFilter
};
