'use strict';

/* jslint indent: 4 */

var fs = require('fs');
var util = require('util');
var Transform = require('stream').Transform;

var fileWalker = require('./fileWalker.js');
var logger = require('./logger.js');
var template = require('./template.js');
var utils = require('./utils.js');

var paths = require('./paths.js');

var dummyBuffer = new Buffer(0);

// remove '\r' from files
function Dos2Unix(options) {
    if (!(this instanceof Dos2Unix)) {
        return new Dos2Unix(options);
    }
    Transform.call(this, options);
}

util.inherits(Dos2Unix, Transform);

Dos2Unix.prototype._transform = function(chunk, encoding, done) {
    var p = 0;

    //debug.log(chunk);
    for (var i = 0; i < chunk.length; i = i + 1) {
        if (chunk[i] === 13) { // '\r'
            this.push(chunk.slice(p, i));
            p = i + 1;
        }
    }
    if (p < chunk.length) {
        this.push(chunk.slice(p, chunk.length));
    }
    done();
};

// add a trailing '/' to the path
function deployDirPath(dir) {
    if (dir[dir.length - 1] === '/') {
        return dir;
    }

    return dir + '/';
}

// returns whether the given file name corresponds to a "grantor" file
function isGrantorFile(file) {
    var ext = paths.extname(file);
    if (ext !== '') {
        return ext === '.hdbsynonymgrantor' || ext === '.hdbgrants';
    } else {
        var base = paths.basename(file);
        return  base === '.hdbgrants';
    }
}

// filter out non-deployable files
function isDeployableFile(file) {
    return !isGrantorFile(file);
}

// modify the path for certain files
function deployFilePath(file) {
    // we keep configured config-templates files where there are, although we have modified them
    // this way, we don't have to re-map errors messages, path filters, etc.

    // rename old .hdbsynonymtemplate to .hdbsynonymconfig
    if (paths.extname(file) === '.hdbsynonymtemplate') {
        file = paths.serverPath(paths.join(paths.dirname(file), paths.basename(file, '.hdbsynonymtemplate') + '.hdbsynonymconfig'));
    }

    return file;
}

function isTemplateFile(file) {
    var fileExtension = paths.extname(file);

    if (fileExtension === '.hdbsynonymtemplate') {
        // it's an old-style synonym template file
        return true;
    }

    if (fileExtension.indexOf('config') === fileExtension.length - 6 && paths.isInCfgDirectory(file)) {
        // it's a new new-style config template file in cfg/
        return true;
    }

    return false;
}

function deployFileContent(root, file, services, stripCRFromCSV) {
    var dos2unix;

    var p = [root, paths.clientPath(file)].join('/');

    var fileExtension = paths.extname(file);

    if (stripCRFromCSV) {
        // replace dos /r/n with unix /n (for csv files)
        if (fileExtension.toLowerCase() === '.csv') {
            dos2unix = new Dos2Unix();
            fs.createReadStream(p).pipe(dos2unix);
            return dos2unix;
        }
    }

    // process templates
    if (isTemplateFile(file)) {
        var result = template.convertTemplate(utils.readJSONFile(p), services);
        if (result.converted) {
            return new Buffer(JSON.stringify(result.content));
        }
    }

    return fs.createReadStream(p);
}

// check and collect a single module
function collectSingleReusableModule(root, modulePath, scopePath, cb) {
    // modulePath already has a trailing /
    var node_modules = 'node_modules/';
    if (fs.existsSync(paths.join(root, paths.clientPath(modulePath + 'src/.hdiconfig')))) {
        if (fs.existsSync(paths.join(root, paths.clientPath(modulePath + node_modules)))) {
            throw new Error('Nested node_modules found at ' + modulePath);
        }
        cb(modulePath, scopePath);
    }
}

// find node_modules/<module> folders, where node_modules/<module>/src contains a .hdiconfig file
function collectReusableModules(root, cb) {
    var rootPaths = [];
    var node_modules = 'node_modules/';
    if (fs.existsSync(paths.join(root, paths.clientPath(node_modules)))) {
        var moduleDirs = fs.readdirSync(paths.join(root, paths.clientPath(node_modules)));

        moduleDirs.forEach(function(dir) {
            if (dir.startsWith('@')) {
                // this is a scoped module folder at node_modules/@<scope>/; collect scoped modules
                var scopePath = node_modules + dir + '/';
                var scopedModuleDirs = fs.readdirSync(paths.join(root, paths.clientPath(scopePath)));
                scopedModuleDirs.forEach(function(dir) {
                    // this is a scoped module at node_modules/@<scope>/<module>/
                    var modulePath = scopePath + dir + '/';
                    collectSingleReusableModule(root, modulePath, scopePath, cb);
                });
            } else {
                // this is a non-scoped module at node_modules/<module>/
                var modulePath = node_modules + dir + '/';
                collectSingleReusableModule(root, modulePath, null, cb);
            }
        });
    }
    return rootPaths;
}

module.exports = function(root, services, workingSet, deployDirs, pathFilter, stripCRFromCSV) {
    var
        dirs = [],
        files = [];

    //file walker functions
    function enterDir(/*level, dir*/) {
        return true;
    }

    function leaveDir(level, dir, found) {
        if (found) {
            dir = paths.serverPath(dir);
            dirs.push(dir);
        }
    }

    function addFile(level, dir, file) {
        // skip .gitignore files
        if (paths.basename(file) === '.gitignore') {
            return false;
        }

        file = paths.serverPath(file);

        // apply the filter for paths
        // we apply the path filter in the file walk to ensure that it also affects files which are handled by the deployer application itself, e.g. template files
        if (!pathFilter.matchesPath(file)) {
            // directory is not in the filter, or file itself is not in the filter; skip the file
            return false;
        }

        // file needs to be added
        files.push(file);
        return true;
    }

    logger.logTimerInit('collect-files', "Collecting files...");

    // the collect directories are our deploy directories plus the src/ + cfg/ directories of modules
    var collectDirs = deployDirs;

    var reuseModulesCount = 0;
    collectReusableModules(root, function(modulePath, scopePath) {
        modulePath = paths.serverPath(modulePath);
        // directories in collectDirs will be pushed to dirs automatically
        collectDirs.push(modulePath + 'src/');
        collectDirs.push(modulePath + 'cfg/');
        // but, we need to push the root path of the module manually
        dirs.push(modulePath);
        // and, we also need to push the scope's path manually, if it's defined
        if (scopePath) {
            scopePath = paths.serverPath(scopePath);
            if (dirs.indexOf(scopePath) === -1) {
                dirs.push(scopePath);
            }
        }
        reuseModulesCount++;
    });
    if (reuseModulesCount) {
        // also push the lib/
        dirs.push(paths.serverPath('lib/'));
    }

    // collect now
    fileWalker.walk(root, collectDirs, enterDir, leaveDir, addFile);

    var defaultAccessRoleFile = 'src/defaults/default_access_role.hdbrole';

    var result = {
        root: root,
        serverTopDirs: function() {
            // the directories to consider on the server-side are always our given deployDirs
            // no matter which directories we've found locally, e.g. a cfg/ might not exist locally, but on the server
            // with reusable modules, we also need 'lib/' here
            return [].concat(
                deployDirs.map(function(dir) {
                    return [deployDirPath(dir)];
                }),
                [ ['lib/'] ]
            );
        },
        deployFiles: function() {
            return files.filter(isDeployableFile).map(function(file) {
                return [deployFilePath(file)];
            });
        },
        deployContent: function() {
            return [].concat(
                dirs.map(function(dir) {
                    return [deployDirPath(dir), dummyBuffer];
                }),
                files.filter(isDeployableFile).map(function(file) {
                    return [deployFilePath(file), deployFileContent(root, file, services, stripCRFromCSV)];
                })
            );
        },
        synonymGrantorFiles: function() {
            return files.filter(function(file) {
                if (!isGrantorFile(file)) {
                    return false;
                }
                if (!workingSet.matchesPath(file)) {
                    return false;
                }
                return true;
            }).map(function(file) {
                return file;
            });
        },
        containsDefaultAccessRoleFile: function() {
            if (!workingSet.matchesPath(defaultAccessRoleFile)) {
                return false;
            }
            if (!pathFilter.matchesPath(defaultAccessRoleFile)) {
                return false;
            }
            if (!fs.existsSync(paths.join(root, defaultAccessRoleFile))) {
                return false;
            }
            return true;
        },
        checkDefaultAccessRoleFile: function() {
            var roleJSON = utils.readJSONFile(paths.join(root, defaultAccessRoleFile));

            if (!roleJSON.hasOwnProperty('role')) {
                return 'Invalid default-access-role file "' + defaultAccessRoleFile + '": key "role" not found';
            }

            if (!roleJSON.role.hasOwnProperty('name')) {
                return 'Invalid default-access-role file "' + defaultAccessRoleFile + '": key "name" in object "role" not found';
            }

            var name = roleJSON.role.name;
            if (name !== 'default_access_role') {
                return 'Invalid default-access-role file "' + defaultAccessRoleFile + '": file does not define the "default_access_role" role';
            }

            return undefined;
        }
    };

    logger.logTimerDelta('collect-files', "Collecting files... ok");

    logger.log(dirs.length + ' directories collected');
    logger.log(files.length + ' files collected');
    logger.log(reuseModulesCount + ' reusable modules collected');

    return result;
};
