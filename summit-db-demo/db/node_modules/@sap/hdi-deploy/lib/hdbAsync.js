'use strict';

/* jslint indent: 4 */

var async = require('async');
var hdb = require('hdb');

var logger = require('./logger.js');

function identifier(name) {
    // escape " inside identifiers to ""
    name = name.replace(/\"/g, '""');
    // surround result with "..."
    return '"' + name + '"';
}

function newArray(length, val) {
    var
        a = [],
        i;

    for (i = 0; i < length; i = i + 1) {
        a[i] = val;
    }
    return a;
}

function indentSpaces(n) {
    var
        spaces = '',
        i;

    for (i = 0; i < n; i = i + 1) {
        spaces += ' ';
    }
    return spaces;
}

function printMessagesToConsole(logger, messages) {
    messages.forEach(function(message) {
        var
            indent,
            showDetails,
            id = '',
            locationRowCol = [],
            locationText = '';

        if (message.MESSAGE === 'END') {
            return;
        }

        indent = indentSpaces(message.LEVEL + 1);
        showDetails = message.SEVERITY === 'ERROR' || message.SEVERITY === 'WARNING';

        if (showDetails) {
            id = message.PLUGIN_ID;
            if (!id) {
                id = message.LIBRARY_ID;
            }

            var severity = (message.SEVERITY === 'ERROR') ? "Error" : "Warning";

            if (id) {
                logger.logVerbose('%s%s: %s: %s [%s]', indent, severity, id, message.MESSAGE, message.MESSAGE_CODE);
            } else {
                logger.logVerbose('%s%s: %s [%s]', indent, severity, message.MESSAGE, message.MESSAGE_CODE);
            }

            if (message.PATH) {
                if (message.LOCATION) {
                    locationRowCol.push(message.LOCATION);
                }
                if (message.LOCATION_PATH) {
                    locationRowCol.push(message.LOCATION_PATH);
                }
                if (locationRowCol.length !== 0) {
                    locationText = '(' + locationRowCol.join(',') + ')';
                }
                logger.logVerbose('%s  at "%s" %s', indent, message.PATH, locationText);
            }

        } else {
            logger.logVerbose('%s%s', indent, message.MESSAGE);
        }

    });
}

function logMessagesToFileAndParent(logger, messages) {
    messages.forEach(function(message) {
        if (message.MESSAGE === 'END') {
            return;
        }

        var jsonObject = {
            id: logger.nextMessageId(),
            origin: 'server',
            request_id: message.REQUEST_ID,
            row_id: message.ROW_ID,
            level: message.LEVEL,
            type: message.TYPE,
            library_id: message.LIBRARY_ID,
            plugin_id: message.PLUGIN_ID,
            path: message.PATH,
            severity: message.SEVERITY,
            message_code: message.MESSAGE_CODE,
            message: message.MESSAGE,
            location: message.LOCATION,
            location_path: message.LOCATION_PATH,
            timestamp_utc: message.TIMESTAMP_UTC
        };

        logger.logToFile(jsonObject);
        logger.logToParent(jsonObject);
    });
}

function printMessages(logger, messages) {
    if ( !Array.isArray(messages) ) {
        messages = [ messages ];
    }
    printMessagesToConsole(logger, messages);
    logMessagesToFileAndParent(logger, messages);
}

// print hdi stored procedure call result
function printResult(cb, parameters, messages) {
    printMessages(logger, messages);
    cb(null);
}

// check hdi stored procedure call result
function checkResult(phase, silent, expectedErrorMessageCodes) {
    return function(cb, parameters, messages) {
        if (parameters.RETURN_CODE >= 0) {
            if (!silent) {
                printMessages(logger, messages);
            }
            cb(null, {
                phase: phase,
                messages: messages
            });
            return;
        }

        // it's an error situation
        if (expectedErrorMessageCodes) {
            var foundMessageErrorCodes = 0;
            for (var i = 0; i < expectedErrorMessageCodes.length; ++i) {
                var expectedErrorMessageCode = expectedErrorMessageCodes[i];
                for (var j = 0; j < messages.length; ++j) {
                    if (messages[j].MESSAGE_CODE === expectedErrorMessageCode) {
                        ++foundMessageErrorCodes;
                        break;
                    }
                }
            }

            if (foundMessageErrorCodes === expectedErrorMessageCodes.length) {
                // ignore this error if all expected error message codes are in the messages
                cb(null, {
                    phase: phase,
                    messages: messages
                });
                return;
            }
        }

        printMessages(logger, messages);
        cb(new Error('HDI call failed'));
    };
}

module.exports = function(host, port, user, password, certificate, dbhosts) {
    var credentials = {
            user: user,
            password: password
        };

    if (Array.isArray(dbhosts)) {
        credentials.hosts = dbhosts;
    } else {
        credentials.host = host;
        credentials.port = port;
    }

    if (certificate) {
        credentials.ca = [ certificate ];
    }

    var client;
    if (host) {
        client = hdb.createClient(credentials);
    }

    function formatSqlError(sql, err) {
        if (err) {
            logger.trace(err);
            return new Error('Error executing: ' + sql + ';\n (nested message: ' + err.message + ')');
        }
        return null;
    }

    function connect() {
        return function(cb) {
            logger.trace("hdb connect: ", credentials);
            client.connect(cb);
        };
    }

    function disconnect() {
        return function(cb) {
            logger.trace('hdb disconnect');
            client.close();
            cb();
        };
    }

    function execute(sql) {
        return function(cb) {
            logger.trace('hdb exec', sql);
            client.exec(sql, function(err, rows) {
                cb(formatSqlError(sql, err), rows);
            });
        };
    }

    function insert(sql, data) {
        // no data -> avoid driver error (Invalid input parameter values)
        if (!data.length) {
            return function(cb) {
                cb(null, null);
            };
        }

        return function(cb) {
            //logger.trace('hdb insert', sql, data);
            logger.trace('hdb insert', sql);
            async.waterfall([
                function(cb) {
                    client.prepare(sql, cb);
                },
                function(stmt, cb) {
                    stmt.exec(data, cb);
                }
            ], function(err, results) {
                cb(formatSqlError(sql, err), results);
            });
        };
    }

    // stored procedure returns 1 table result
    function callproc1(sql, input, fct) {
        input = input || {}; // if undefined - hdb driver exception

        return function(cb) {
            logger.trace('hdb call proc prepare: %s', sql);
            async.waterfall([
                function(cb) {
                    client.prepare(sql, cb);
                },
                function(stmt, cb) {
                    stmt.exec(input, cb);
                },
                function(parameters, messages, cb) {
                    if (fct) {
                        fct(cb, parameters, messages);
                    } else {
                        cb(null);
                    }
                }
            ], function(err, results) {
                cb(formatSqlError(sql, err), results);
            });
        };
    }

    // stored procedure returns 2 table results
    function callproc2(sql, input, fct) {
        input = input || {}; // if undefined - hdb driver exception

        return function(cb) {
            logger.trace('hdb call proc prepare: %s', sql);
            async.waterfall([
                function(cb) {
                    client.prepare(sql, cb);
                },
                function(stmt, cb) {
                    stmt.exec(input, cb);
                },
                function(parameters, messages, result, cb) {
                    if (fct) {
                        fct(cb, parameters, messages, result);
                    } else {
                        cb(null);
                    }
                }
            ], function(err, results) {
                cb(formatSqlError(sql, err), results);
            });
        };
    }

    function setSchema(schema) {
        // workaround - check in which schema the creation of local temporary tables is possible
        // - use schema in GoBroker / hdb 0.9
        // - use schema + #DI in JavaBroker / hdb 0.10
        return function(cb) {
            async.series([
                execute('SET SCHEMA ' + identifier(schema + '#DI')),
                execute('CREATE LOCAL TEMPORARY ROW TABLE #TEST LIKE _SYS_DI.TT_PARAMETERS')
            ], function(err, results) {
                if (!err) {
                    cb(err, results);
                    return;
                }
                execute('SET SCHEMA ' + identifier(schema))(cb);
            });
        };
    }

    return {
        end: function() {
            client.end();
        },

        connect: function() {
            return connect();
        },

        disconnect: function() {
            return disconnect();
        },

        execute: execute,

        setAutoCommit: function(val) {
            return function(cb) {
                client.setAutoCommit(val);
                cb();
            };
        },

        createTmpTables: function(tables) {
            var tasks = tables.map(function(table) {
                return execute('CREATE LOCAL TEMPORARY ROW TABLE ' + table[0] + ' LIKE ' + table[1]);
            });

            return function(cb) {
                async.series(tasks, cb);
            };
        },

        dropTmpTables: function(tables) {
            var tasks = tables.map(function(table) {
                return execute('DROP TABLE ' + table[0]);
            });

            return function(cb) {
                async.series(tasks, cb);
            };
        },

        setSchema: setSchema,

        //setSchema: function (schema) {
        //  return execute('SET SCHEMA ' + identifier(schema + '#DI'));
        //},

        bulkInsert: function(table, fields, values) {
            var fieldList = ' (' + fields.map(function(field) {
                return identifier(field);
            }).join(', ') + ') ';

            return insert('INSERT INTO ' + table + fieldList + ' VALUES (' + newArray(fields.length, '?').join(', ') + ')', values);
        },

        createUser: function(user, password) {
            return function(cb) {
                async.series([
                    execute('CREATE RESTRICTED USER ' + user + ' PASSWORD ' + password),
                    execute('ALTER USER ' + user + ' ENABLE CLIENT CONNECT'),
                    execute('ALTER USER ' + user + ' DISABLE PASSWORD LIFETIME')
                ], cb);
            };
        },

        dropUser: function(user, cascade) {
            if (cascade) {
                return execute('DROP USER ' + user + ' CASCADE');
            }
            return execute('DROP USER ' + user);
        },

        createRole: function(role) {
            return execute('CREATE ROLE ' + identifier(role));
        },

        dropRole: function(role) {
            return execute('DROP ROLE ' + identifier(role));
        },

        grantRole: function(role, grantee) {
            return execute('GRANT ' + identifier(role) + ' TO ' + identifier(grantee));
        },

        grantRoles: function(roles, grantee, withAdminOption) {
            var sql = 'GRANT ' + roles.map(identifier).join(',') + ' TO ' + identifier(grantee);

            if (withAdminOption) {
                sql += ' WITH ADMIN OPTION';
            }

            return execute(sql);
        },

        grantSchemaRoles: function(schema, roles, grantee, withAdminOption) {
            var sql = 'GRANT ' + roles.map(function(role) { return identifier(schema) + '.' + identifier(role); }).join(',') + ' TO ' + identifier(grantee);

            if (withAdminOption) {
                sql += ' WITH ADMIN OPTION';
            }

            return execute(sql);
        },

        grantSystemPrivileges: function(privileges, grantee, withAdminOption) {
            var sql = 'GRANT ' + privileges.map(identifier).join(',') + ' TO ' + identifier(grantee);

            if (withAdminOption) {
                sql += ' WITH ADMIN OPTION';
            }

            return execute(sql);
        },

        grantSchemaPrivileges: function(privileges, schema, grantee, withGrantOption) {
            var sql = 'GRANT ' + privileges.map(identifier).join(',') + ' ON SCHEMA ' + identifier(schema) + ' TO ' + identifier(grantee);

            if (withGrantOption) {
                sql += ' WITH GRANT OPTION';
            }

            return execute(sql);
        },

        grantObjectPrivileges: function(privileges, schema, obj, grantee, withGrantOption) {
            var
                objName = schema ? [identifier(schema), identifier(obj)].join('.') : identifier(obj),
                sql = 'GRANT ' + privileges.map(identifier).join(',') + ' ON ' + objName + ' TO ' + identifier(grantee);

            if (withGrantOption) {
                sql += ' WITH GRANT OPTION';
            }

            return execute(sql);
        },

        grantGlobalObjectPrivileges : function(privileges, obj, type, grantee, withGrantOption) {
            if (type !== 'REMOTE SOURCE') {
                throw new Error(obj + ' must be of type REMOTE SOURCE');
	    }

	    var sql = 'GRANT ' + privileges.map(identifier).join(',') + ' ON ' + type + ' ' + identifier(obj) + ' TO ' + identifier(grantee);

            if (withGrantOption) {
                sql += ' WITH GRANT OPTION';
            }

            return execute(sql);
        },

        hdiSysGrantSchemaPrivileges: function(schema, privTable, prmsTable, cb) {
            return callproc1('CALL _SYS_DI.GRANT_CONTAINER_SCHEMA_PRIVILEGES(' + ['?', privTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', {
                CONTAINER_NAME: schema
            }, cb);
        },

        //hdiGrantApiPrivileges: function (schema, privTable, prmsTable, cb) {
        //  return callproc1('CALL ' + identifier(schema + '#DI') + '.GRANT_CONTAINER_API_PRIVILEGES(' + [privTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
        //},

        hdiGrantSchemaRoles: function(schema, rolesTable, prmsTable, cb) {
            return callproc1('CALL ' + identifier(schema + '#DI') + '.GRANT_CONTAINER_SCHEMA_ROLES(' + [rolesTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
        },

        hdiRevokeSchemaPrivileges: function(schema, privTable, prmsTable, cb) {
            return callproc1('CALL ' + identifier(schema + '#DI') + '.REVOKE_CONTAINER_SCHEMA_PRIVILEGES(' + [privTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
        },

        hdiDelete: function(schema, delTable, prmsTable, cb) {
            return callproc1('CALL ' + identifier(schema + '#DI') + '.DELETE(' + [delTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
        },

        hdiWrite: function(schema, writeTable, prmsTable, cb) {
            return callproc1('CALL ' + identifier(schema + '#DI') + '.WRITE(' + [writeTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
        },

        hdiStatus: function(schema, statTable, prmsTable, cb) {
            return callproc2('CALL ' + identifier(schema + '#DI') + '.STATUS(' + [statTable, prmsTable].concat(newArray(4, '?')).join(', ') + ')', null, cb);
        },

        hdiMake: function(schema, deployTable, undeployTable, folderprmsTable, prmsTable, cb) {
            return callproc1('CALL ' + identifier(schema + '#DI') + '.MAKE(' + [deployTable, undeployTable, folderprmsTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
        },

        hdiPrintResult: printResult,

        hdiCheckResult: checkResult,

        printMessages: printMessages
    };
};
