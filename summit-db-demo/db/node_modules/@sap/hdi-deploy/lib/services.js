'use strict';

/* jslint indent: 4 */

var xsenv = require('@sap/xsenv');

function ServiceAccessor() {

    this.services = xsenv.filterCFServices(function(service) {
        if (service.tags && service.tags.indexOf('hana') !== -1) {
            return true;
        }
        if (service.label === 'user-provided' && service.credentials.tags && service.credentials.tags.indexOf('hana') !== -1) {
            return true;
        }
        return false;
    });

    // read service replacements from environment and store them in serviceReplacements
    this.serviceReplacements = {};
    this.getServiceReplacements = function() {
        return this.serviceReplacements;
    };

    this.useServiceReplacements = false;
    this.usingServiceReplacements = function() {
        return this.useServiceReplacements;
    };

    if (typeof process.env.SERVICE_REPLACEMENTS !== "undefined") {
        var serviceReplacementsFromEnv = [];
        try {
            serviceReplacementsFromEnv = JSON.parse(process.env.SERVICE_REPLACEMENTS);
        } catch (error) {
            throw new Error('Failed to parse JSON object in SERVICE_REPLACEMENTS: ' + error);
        }
        if (!Array.isArray(serviceReplacementsFromEnv)) {
            throw new Error('Failed to parse JSON object in SERVICE_REPLACEMENTS: SERVICE_REPLACEMENTS must be an array');
        }
        for (var i = 0; i < serviceReplacementsFromEnv.length; ++i) {
            if (!serviceReplacementsFromEnv[i].key) {
                throw new Error('Failed to parse JSON object in SERVICE_REPLACEMENTS: SERVICE_REPLACEMENTS does not define a key for element ' + i);
            }
            if (!serviceReplacementsFromEnv[i].service) {
                throw new Error('Failed to parse JSON object in SERVICE_REPLACEMENTS: SERVICE_REPLACEMENTS does not define a service for element ' + i);
            }
            if (this.serviceReplacements.hasOwnProperty(serviceReplacementsFromEnv[i].key)) {
                throw new Error('Failed to parse JSON object in SERVICE_REPLACEMENTS: SERVICE_REPLACEMENTS contains duplicate entries for the key ' + serviceReplacementsFromEnv[i].key);
            }
            this.serviceReplacements[serviceReplacementsFromEnv[i].key] = serviceReplacementsFromEnv[i];
        }

        this.useServiceReplacements = true;
    }

    // internal function which returns the bound service with the given name, or null if not found
    this.getServiceInternal = function (serviceName) {
        for (var i = 0; i < this.services.length; i = i + 1) {
            if (this.services[i].name === serviceName) {
                return this.services[i];
            }
        }
        return null;
    };

    // returns the bound service with the given name, throws an error if not found
    this.getServiceOrThrow = function(serviceName) {
        var service = this.getServiceInternal(serviceName);
        if (service === null) {
            throw new Error('service ' + serviceName + ' not found; either the service definition does not exist or it is not tagged with the tag "hana"');
        }
        return service;
    };

    // returns the bound service with the given name using the service replacements map, throws an error if not found
    this.getServiceUsingServiceReplacements = function(serviceName) {
        if (this.serviceReplacements.hasOwnProperty(serviceName)) {
            // look up real service name via replacement map
            var realServiceName = this.serviceReplacements[serviceName].service;
            // get the real service
            var service = this.getServiceInternal(realServiceName);
            if (service === null) {
                throw new Error('service ' + realServiceName + ' as replacement for service ' + serviceName + ' not found; either the service definition does not exist or it is not tagged with the tag "hana"');
            }
            return service;
        } else {
            // service name is not mapped via replacement map, directly get the real service
            return this.getServiceOrThrow(serviceName);
        }
    };

    // returns the service which represents the target container
    this.getTarget = function() {
        if (process.env.TARGET_CONTAINER) {
            return this.getServiceOrThrow(process.env.TARGET_CONTAINER);
        }

        switch (this.services.length) {
        case 0:
            throw new Error('no service definition found; there must be at least one service definition for the deployment target');
        case 1:
            return this.services[0];
        default:
            throw new Error('more than one service definition found, but no service is defined as the deployment target via the environment variable "TARGET_CONTAINER"');
        }
    };

    this.getTargetCreds = function() {
        var target = this.getTarget();
        return target ? target.credentials : null;
    };

    this.getCreds = function (serviceName) {
        return this.getServiceUsingServiceReplacements(serviceName).credentials;
    };

    this.getService = this.getServiceUsingServiceReplacements;
}

module.exports = function() {
    return new ServiceAccessor();
};
