'use strict';

/* jslint indent: 4 */

var async = require('async');

var hdb = require('./hdbAsync.js');
var hdiTables = require('./hdiTables.js');
var logger = require('./logger.js');
var utils = require('./utils.js');
var paths = require('./paths.js');

function selectSchema() {
    // return the first non-undefined argument
    for (var i = 0; i < arguments.length; ++i) {
        var schema = arguments[i];
        if (schema !== undefined) {
            return schema;
        }
    }
    return '';
}

function grantPrivileges(client, grantor_is_hdi_container, privileges, grantee, grantor_schema, grantor_remote, cb) {
    var tasks = [];
    var container_roles = [];

    // the rule for schema selection is:
    // 1. obj.schema
    // 2. obj.reference, only used for schema_privileges
    // 3. grantor_schema

    if (privileges.roles) {
        // roles is supported for backwards compatibility
        // string format: "roles": [ "X", "Y" ]
        // object format: "roles": [ { "names": [ "X", "Y" ], "roles": [ "X", "Y" ], "roles_with_admin_option": [ "A", "B" ] } ]
        var string_format_roles = [];
        privileges.roles.forEach(function(obj) {
            if (typeof obj === 'string') {
                string_format_roles.push(obj);
            } else {
                if (obj.names) {
                    tasks.push(client.grantRoles(obj.names, grantee, false));
                }
                if (obj.roles) {
                    tasks.push(client.grantRoles(obj.roles, grantee, false));
                }
                if (obj.roles_with_admin_option) {
                    tasks.push(client.grantRoles(obj.roles_with_admin_option, grantee, true));
                }
            }
        });

        if (string_format_roles.length > 0) {
            tasks.push(client.grantRoles(string_format_roles, grantee, false));
        }
    }

    if (privileges.global_roles) {
        // global_roles is supported for symmetry with hdbrole
        // string format: "global_roles": [ "X", "Y" ]
        // object format: "global_roles": [ { "names": [ "X", "Y" ], "roles": [ "X", "Y" ], "roles_with_admin_option": [ "A", "B" ] } ]
        var string_format_global_roles = [];
        privileges.global_roles.forEach(function(obj) {
            if (typeof obj === 'string') {
                string_format_global_roles.push(obj);
            } else {
                if (obj.names) {
                    tasks.push(client.grantRoles(obj.names, grantee, false));
                }
                if (obj.roles) {
                    tasks.push(client.grantRoles(obj.roles, grantee, false));
                }
                if (obj.roles_with_admin_option) {
                    tasks.push(client.grantRoles(obj.roles_with_admin_option, grantee, true));
                }
            }
        });

        if (string_format_global_roles.length > 0) {
            tasks.push(client.grantRoles(string_format_global_roles, grantee, false));
        }
    }

    if (privileges.system_privileges) {
        // string format: "system_privileges": [ "X", "Y" ]
        // object format: "system_privileges": [ { "privileges": [ "X", "Y" ], "privileges_with_admin_option": [ "A", "B" ] } ]
        var string_format_privileges = [];
        privileges.system_privileges.forEach(function(obj) {
            if (typeof obj === 'string') {
                string_format_privileges.push(obj);
            } else {
                if (obj.privileges) {
                    tasks.push(client.grantSystemPrivileges(obj.privileges, grantee, false));
                }
                if (obj.privileges_with_admin_option) {
                    tasks.push(client.grantSystemPrivileges(obj.privileges_with_admin_option, grantee, true));
                }
            }
        });

        if (string_format_privileges.length > 0) {
            tasks.push(client.grantSystemPrivileges(string_format_privileges, grantee, false));
        }
    }

    if (privileges.schema_privileges) {
        privileges.schema_privileges.forEach(function(obj) {
            if (obj.privileges) {
                tasks.push(client.grantSchemaPrivileges(obj.privileges, selectSchema(obj.schema, obj.reference, grantor_schema), grantee, false));
            }
            if (obj.privileges_with_grant_option) {
                tasks.push(client.grantSchemaPrivileges(obj.privileges_with_grant_option, selectSchema(obj.schema, obj.reference, grantor_schema), grantee, true));
            }
        });
    }

    if (privileges.object_privileges) {
        privileges.object_privileges.forEach(function(obj) {
            if (obj.privileges) {
                tasks.push(client.grantObjectPrivileges(obj.privileges, selectSchema(obj.schema, grantor_schema), obj.name, grantee, false));
            }
            if (obj.privileges_with_grant_option) {
                tasks.push(client.grantObjectPrivileges(obj.privileges_with_grant_option, selectSchema(obj.schema, grantor_schema), obj.name, grantee, true));
            }
        });
    }

    if (privileges.global_object_privileges) {
        privileges.global_object_privileges.forEach(function(obj) {
            var name = obj.name;
            if (typeof name === 'undefined' && obj.type === 'REMOTE SOURCE') {
                name = grantor_remote;
            }

            if (obj.privileges) {
                tasks.push(client.grantGlobalObjectPrivileges(obj.privileges, name, obj.type, grantee, false));
            }
            if (obj.privileges_with_grant_option) {
                tasks.push(client.grantGlobalObjectPrivileges(obj.privileges_with_grant_option, name, obj.type, grantee, true));
            }
        });
    }

    if (privileges.schema_roles) {
        // string format: "schema_roles": [ "X", "Y" ]
        // object format: "schema_roles": [ { "names": [ "X", "Y" ], "roles": [ "X", "Y" ], "roles_with_admin_option": [ "A", "B" ] } ]
        if (grantor_is_hdi_container) {
            privileges.schema_roles.forEach(function(obj) {
                if (obj.schema) {
                    cb(new Error('"schema" is not supported in "schema_roles" in case of an HDI container service binding'));
                    return;
                }
                if (typeof obj === 'string') {
                    container_roles.push([obj, grantee]);
                } else {
                    if (obj.names) {
                        obj.names.forEach(function(role) {
                            container_roles.push([role, grantee]);
                        });
                    }
                    if (obj.roles) {
                        obj.roles.forEach(function(role) {
                            container_roles.push([role, grantee]);
                        });
                    }
                    if (obj.roles_with_admin_option) {
                        cb(new Error('"roles_with_admin_option" is not supported in "schema_roles" in case of an HDI container service binding'));
                        return;
                    }
                }
            });
        } else {
            var string_format_schema_roles = [];
            privileges.schema_roles.forEach(function(obj) {
                if (typeof obj === 'string') {
                    string_format_schema_roles.push(obj);
                } else {
                    if (obj.names) {
                        tasks.push(client.grantSchemaRoles(selectSchema(obj.schema, grantor_schema), obj.names, grantee, false));
                    }
                    if (obj.roles) {
                        tasks.push(client.grantSchemaRoles(selectSchema(obj.schema, grantor_schema), obj.roles, grantee, false));
                    }
                    if (obj.roles_with_admin_option) {
                        tasks.push(client.grantSchemaRoles(selectSchema(obj.schema, grantor_schema), obj.roles_with_admin_option, grantee, true));
                    }
                }
            });

            if (string_format_schema_roles.length > 0) {
                tasks.push(client.grantSchemaRoles(grantor_schema, string_format_schema_roles, grantee, false));
            }
        }
    }

    if (privileges.container_roles) {
        // collect container roles into container_roles
        privileges.container_roles.forEach(function(role) {
            container_roles.push([role, grantee]);
        });
    }

    if (container_roles.length > 0) {
        // grant all container roles which were collected into container_roles
        var tempTablesForContainerRoles = [
            ['#CONTAINER_ROLES_PARAMETERS', hdiTables.parameters.type],
            ['#CONTAINER_ROLES', hdiTables.schemaRoles.type]
        ];

        tasks.push(client.createTmpTables(tempTablesForContainerRoles));

        tasks.push(client.bulkInsert('#CONTAINER_ROLES', hdiTables.schemaRoles.fields, container_roles));
        tasks.push(client.hdiGrantSchemaRoles(grantor_schema, '#CONTAINER_ROLES', '#CONTAINER_ROLES_PARAMETERS', client.hdiCheckResult('grant container roles', true)));

        tasks.push(client.dropTmpTables(tempTablesForContainerRoles));
    }

    async.series(tasks, cb);

}

function grantUsers(privileges, grantor, fileName, creds, targetCreds, container, user, cb) {
    var tasks = [];
    var grantor_is_hdi_container = creds.hdi_user ? true : false;

    var host = creds.host;
    var port = creds.port;
    var hosts = creds.db_hosts;
    var certificate = creds.certificate;

    if (!Array.isArray(hosts) && host === undefined && port === undefined && certificate === undefined) {
        // host, port, certificate are optional in the service credentials, fallback to target credentials if undefined
        host = targetCreds.host;
        port = targetCreds.port;
        hosts = targetCreds.db_hosts;
        certificate = targetCreds.certificate;
    }

    var client = grantor_is_hdi_container ? hdb(host, port, creds.hdi_user, creds.hdi_password, certificate, hosts)
                                          : hdb(host, port, creds.user, creds.password, certificate, hosts);

    tasks.push(client.connect());
    if (creds.schema) {
        tasks.push(client.setSchema(creds.schema));
    }

    if (privileges.object_owner) {
        tasks.push(function(cb) {
            grantPrivileges(client, grantor_is_hdi_container, privileges.object_owner, container, creds.schema, creds.remote, cb);
        });
    }

    if (privileges.application_user) {
        tasks.push(function(cb) {
            grantPrivileges(client, grantor_is_hdi_container, privileges.application_user, user, creds.schema, creds.remote, cb);
        });
    }

    tasks.push(client.disconnect());

    async.series(tasks, function(err, results) {
        client.end();

        if (err) { // add information about grantor service & underlying user
            err.message += '\ngrantor service: ' + grantor + ', granting user: ';
            if (creds.hdi_user) {
               err.message += creds.hdi_user + ' (hdi_user)';
           } else {
               err.message += creds.user;
           }

            err.message += '\nfile name: ' + fileName;
        }

        cb(err, results);
    });

}

function grantFile(services, root, fileName, container, user, cb) {
    var
        file,
        tasks = [];

    fileName = paths.join(root, paths.clientPath(fileName));

    try {
        file = utils.readJSONFile(fileName);
    } catch (err) {
        cb(err);
        return;
    }

    var targetCreds = services.getTargetCreds();

    Object.keys(file).forEach(function(grantor) {
        var creds;
        try {
            creds = services.getCreds(grantor);
        } catch (err) {
            cb(err);
            return;
        }

        logger.trace('grantor', file[grantor]);

        tasks.push(function(cb) {
            grantUsers(file[grantor], grantor, fileName, creds, targetCreds, container, user, cb);
        });

    });

    async.series(tasks, cb);

}

// grant target container oo and target container access role
exports.grant = function(options, services, content, container, user, cb) {
    try {
        var
            tasks = [],
            fileNames;

        logger.logTimerInit('grants-files', "Processing grants files...");

        fileNames = content.synonymGrantorFiles();
        logger.trace('grants files:', fileNames);

        fileNames.forEach(function(fileName) {
            if (options.workingSet.matchesPath(fileName)) {
                tasks.push(logger.logfn(' Processing "' + fileName + '"...'));
                tasks.push(function(cb) {
                    grantFile(services, content.root, fileName, container, user, cb);
                });
                tasks.push(logger.logfn(' Processing "' + fileName + '"... ok'));
            }
        });

        tasks.push(logger.logfnTimerDelta('grants-files', "Processing grants files... ok"));

        async.series(tasks, function(err, results) {
            cb(err, {
                task: 'synonym',
                results: results
            });
        });
    } catch (err) {
        cb(err);
        return;
    }
};
