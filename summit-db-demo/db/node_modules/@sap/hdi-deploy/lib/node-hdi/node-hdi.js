/* jshint node: true */

'use strict';

var async = require('async');
var hdb = require('hdb');

var TempTables = require('./lib/tempTables.js');
var procHandler = require('./lib/callProcedure.js');
var jobWatcher = require('./lib/jobWatcher.js');

/*
 * helper functions
 */

function _quoted_sql_identifier(identifier) {
    return '"' + identifier.replace(/\"/g, '""') + '"';
}

function _connect(target, loggerCB, callback) {
    target.connection.connect(function(err) {
        if (err) {
            return callback(err);
        }
        if (loggerCB) {
            loggerCB('OK: connected to DB.');
        }
        callback(null, 'OK: connected to DB.');
    });
}

// creates the required temporary tables if necessary
function _create_SYS_DI_temp_tables(target, logger, callback) {
    if (target.sysDiTempTables.init) {
        return callback(null, null);
    }

    var tasks = [
        function(asyncCB) { target.tempTables.createSysDi(asyncCB); }
    ];
    async.series(tasks, function(err, results) {
        if (err) {
            return callback(err);
        }
        target.sysDiTempTables.init = true;
        return callback(null, results);
    });
}

function _create_temp_tables(target, logger, callback) {
    if (target.tempTables.init) {
        return callback(null, null);
    }

    var tasks = [
        //function(asyncCB) { _set_schema(target, logger, asyncCB); },
        function(asyncCB) { target.tempTables.create(target.container, asyncCB); }
    ];
    async.series(tasks, function(err, results) {
        if (err) {
            return callback(err);
        }
        target.tempTables.init = true;
        return callback(null, results);
    });
}

/*
 * API
 */

// general DI procedures

function _configure_di(hdb, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var sql = "CALL _SYS_DI.CONFIGURE_DI(_SYS_DI.#PARAMETERS, ?, ?, ? )";

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);

}

function _configure_di_parameters(hdb, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var sql = "CALL _SYS_DI.CONFIGURE_DI_PARAMETERS(_SYS_DI.#CONFIG_PARAMETERS, _SYS_DI.#PARAMETERS, ?, ?, ? )";

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);

}

function _create_container(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var sql = "CALL _SYS_DI.CREATE_CONTAINER('" + container + "', _SYS_DI.#PARAMETERS, ?, ?, ?)";

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _delete_container(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var sql = "CALL _SYS_DI.DROP_CONTAINER('" + container + "', _SYS_DI.#PARAMETERS, ?, ?, ?)";

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

// returns a result set with structure like  _SYS_DI.TT_LIBRARY_INFORMATION
function _list_libraries(hdb, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var sql = "CALL _SYS_DI.LIST_LIBRARIES(_SYS_DI.#PARAMETERS, ?, ?, ?, ?)";

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

// container-specific procedures

function _configure_container(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.CONFIGURE_CONTAINER(' + schema + '.#PARAMETERS, ?, ?, ? )';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _configure_container_parameters(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.CONFIGURE_CONTAINER_PARAMETERS(' + schema + '.#CONFIG_PARAMETERS, ' + schema + '.#PARAMETERS, ?, ?, ? )';

    return  procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _configure_libraries(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.CONFIGURE_LIBRARIES(' + schema + '.#LIBRARY_CONFIG, ' + schema + '.#PARAMETERS, ?, ?, ? )';

    return  procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _list_configured_libraries(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.LIST_CONFIGURED_LIBRARIES(' + schema + '.#PARAMETERS, ?, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _lock(hdb, container, timeout, callback) {
    if (typeof timeout !== 'number') {
        return callback(new Error('Parameter "timeout" must be a number.'));
    }

    var sql_params = {
        'TIMEOUT': timeout,
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.LOCK(?, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

// show the status of the given files/folders in the containers file systems
// OUT: RETURN_CODE, REQUEST_ID, MESSAGES, RESULT (FILESFOLDELDERS_STATUS)
function _status(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.STATUS(' + schema + '.#PATHS, ' + schema + '.#PARAMETERS, ?, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

// read the requested files/folders from the container's work file system
// OUT: RETURN_CODE, REQUEST_ID, MESSAGES, RESULT (FILESFOLDELDERS_METADATA_CONTENT)
function _read(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.READ(' + schema + '.#PATHS, ' + schema + '.#PARAMETERS, ?, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

// read the requested files/folders from the container's deployed file system
// OUT: RETURN_CODE, REQUEST_ID, MESSAGES, RESULT (FILESFOLDELDERS_METADATA_CONTENT)
function _read_deployed(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.READ_DEPLOYED(' + schema + '.#PATHS, ' + schema + '.#PARAMETERS, ?, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _write(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.WRITE(' + schema + '.#PATHS_CONTENT, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _delete(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.DELETE(' + schema + '.#PATHS, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

// determine groups of objects which can be deployed independently
// OUT: RETURN_CODE, REQUEST_ID, MESSAGES, RESULT (MAKE_GROUPS)
function _get_make_groups(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.GET_MAKE_GROUPS(' + schema + '.#DEPLOY_PATHS, ' + schema + '.#UNDEPLOY_PATHS, ' + schema + '.#PATH_PARAMETERS, ' + schema + '.#PARAMETERS, ?, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _make(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.MAKE(' + schema + '.#DEPLOY_PATHS, ' + schema + '.#UNDEPLOY_PATHS, ' + schema + '.#PATH_PARAMETERS, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _make_async(hdb, container, callback, listener) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.MAKE_ASYNC(' + schema + '.#DEPLOY_PATHS, ' + schema + '.#UNDEPLOY_PATHS, ' + schema + '.#PATH_PARAMETERS, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    function internalCB(err, results) {
        if (err) {
           return callback(err);
        }
        jobWatcher.waitForCompletion(hdb, container, results, listener);
        return callback(null, results);
    }

    if (typeof listener === 'undefined' || listener === null) {
        return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
    } else {
        return procHandler.callHDIProcedure(hdb, sql, sql_params, internalCB);
    }
}

function _grant_api_privileges(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.GRANT_CONTAINER_API_PRIVILEGES(' + schema + '.#API_PRIVILEGES, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _grant_api_privileges_with_grant_option(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.GRANT_CONTAINER_API_PRIVILEGES_WITH_GRANT_OPTION(' + schema + '.#API_PRIVILEGES, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _revoke_api_privileges(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.REVOKE_CONTAINER_API_PRIVILEGES(' + schema + '.#API_PRIVILEGES, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _grant_schema_privileges(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.GRANT_CONTAINER_SCHEMA_PRIVILEGES(' + schema + '.#SCHEMA_PRIVILEGES, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _revoke_schema_privileges(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.REVOKE_CONTAINER_SCHEMA_PRIVILEGES(' + schema + '.#SCHEMA_PRIVILEGES, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _grant_schema_roles(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.GRANT_CONTAINER_SCHEMA_ROLES(' + schema + '.#SCHEMA_ROLES, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

function _revoke_schema_roles(hdb, container, callback) {
    var sql_params = {
        'RETURN_CODE': null,
        'REQUEST_ID': null
    };
    var schema = _quoted_sql_identifier(container + '#DI');
    var sql = 'CALL ' + schema + '.REVOKE_CONTAINER_SCHEMA_ROLES(' + schema + '.#SCHEMA_ROLES, ' + schema + '.#PARAMETERS, ?, ?, ?)';

    return procHandler.callHDIProcedure(hdb, sql, sql_params, callback);
}

/*
 * module exports
 */

module.exports = function(container, loggerCB, credentials) {
    var logger = loggerCB;
    var target = {};
    var target2 = {};
    target.container = container;
    target.connection = hdb.createClient(credentials);
    target.connection.on('error', function(err) {
        loggerCB('Network connection error: ' + err);
    });
    target.tempTables = new TempTables(target.connection, container, logger);
    target.tempTables.init = false;
    target.sysDiTempTables = {};
    target.sysDiTempTables.init = false;

    this.connect = function(externCB) {
        return _connect(target, logger, externCB);
    };

    // only for testing; normally it will be called implicitely
    this.createTempTables = function(externCB) {
        return _create_temp_tables(target, logger, externCB);
    };

    /*
     * general DI methods
     */

    this.configureDI = function(call_params, externCB) {
        var tasks = [
            function(callback) { _create_SYS_DI_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSysDiParameters(call_params, callback); },
            function(callback) { _configure_di(target.connection, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.configureDIParameters = function(di_params, call_params, externCB) {
        var tasks = [
            function(callback) { _create_SYS_DI_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSysDiCOnfigParameters(call_params, callback); },
            function(callback) { target.tempTables.fillSysDiParameters(call_params, callback); },
            function(callback) { _configure_di_parameters(target.connection, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.createContainer = function(container, call_params, externCB) {
        var tasks = [
            function(callback) { _create_SYS_DI_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSysDiParameters(call_params, callback); },
            function(callback) { _create_container(target.connection, container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.deleteContainer = function(container, call_params, externCB) {
        var tasks = [
            function(callback) { _create_SYS_DI_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSysDiParameters(call_params, callback); },
            function(callback) { _delete_container(target.connection, container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.listLibraries = function(call_params, externCB) {
        var tasks = [
            function(callback) { _create_SYS_DI_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSysDiParameters(call_params, callback); },
            function(callback) { _list_libraries(target.connection, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult =  (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    /*
     * container-specific methods
     */

    this.configureContainer = function(call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _configure_container(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.configureContainerParameters = function(container_params, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillConfigParameters(container_params, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _configure_container_parameters(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.configureLibraries = function(libconfig, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillLibraryConfig(libconfig, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _configure_libraries(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.listConfiguredLibraries = function(call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _list_configured_libraries(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult =  (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.lock = function(timeout, call_params, externCB) {
        target2.container = container;
        target2.connection = hdb.createClient(credentials);
        target2.connection.setAutoCommit(false);
        target2.connection.on('error', function(err) {
            logger('Network connection2 error: ' + err);
        });
        target2.tempTables = new TempTables(target2.connection, container, logger);
        target2.tempTables.init = false;
        var tasks = [
            function(callback) { _connect(target2, logger, callback); },
            function(callback) { _create_temp_tables(target2, logger, callback); },
            function(callback) { target2.tempTables.fillParameters(call_params, callback); },
            function(callback) { _lock(target2.connection, target2.container, timeout, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                target2.tempTables = null;
                target2.connection.close();
                return externCB(err);
            }
            var lastResult =  (results.length > 0) ? results[results.length - 1] : results;
            return externCB(null, lastResult);
        });
    };

    this.unlock = function(externCB) {
        target2.tempTables = null;
        target2.connection.close();
        externCB(null, null);
    };

    /**
     * Shows the status of the given files/folders in the container's file systems.
     * @param paths An array of path names (strings)
     * @param call_params An object whose properties are either strings or lists of strings
     */
    this.status = function(paths, call_params, externCB) {
        var tasks = [
            //function(callback) { _set_schema(target, logger, callback); }, // schema must already exist
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPaths(paths, '#PATHS', callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _status(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.read = function(paths, call_params, externCB) {
        var tasks = [
            //function(callback) { _set_schema(target, logger, callback); }, // schema must already exist
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPaths(paths, '#PATHS', callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _read(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.readDeployed = function(paths, call_params, externCB) {
        var tasks = [
            //function(callback) { _set_schema(target, logger, callback); }, // schema must already exist
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPaths(paths, '#PATHS', callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _read_deployed(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.write = function(paths_content, call_params, externCB) {
        var tasks = [
            //function(callback) { _set_schema(target, logger, callback); }, // schema must already exist
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPathsAndContent(paths_content, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _write(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.delete = function(paths, call_params, externCB) {
        var tasks = [
            //function(callback) { _set_schema(target, logger, callback); }, // schema must already exist
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPaths(paths, '#PATHS', callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _delete(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.getMakeGroups = function(deploy_paths, undeploy_paths, path_parameters, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPaths(deploy_paths, '#DEPLOY_PATHS', callback); },
            function(callback) { target.tempTables.fillPaths(undeploy_paths, '#UNDEPLOY_PATHS', callback); },
            function(callback) { target.tempTables.fillPathParameters(path_parameters, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _get_make_groups(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.make = function(deploy_paths, undeploy_paths, path_parameters, call_params, externCB) {
        var tasks = [
            //function(callback) { _set_schema(target, logger, callback); }, // schema must already exist
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPaths(deploy_paths, '#DEPLOY_PATHS', callback); },
            function(callback) { target.tempTables.fillPaths(undeploy_paths, '#UNDEPLOY_PATHS', callback); },
            function(callback) { target.tempTables.fillPathParameters(path_parameters, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _make(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.makeAsync = function(deploy_paths, undeploy_paths, path_parameters, call_params, externCB, listenerCB) {
        var tasks = [
            //function(callback) { _set_schema(target, logger, callback); }, // schema must already exist
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillPaths(deploy_paths, '#DEPLOY_PATHS', callback); },
            function(callback) { target.tempTables.fillPaths(undeploy_paths, '#UNDEPLOY_PATHS', callback); },
            function(callback) { target.tempTables.fillPathParameters(path_parameters, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _make_async(target.connection, target.container, callback, listenerCB); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            //console.log(">>> results: ", results);
            if (logger && lastResult) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.grantContainerApiPrivileges = function(privileges, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillApiPrivileges(privileges, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _grant_api_privileges(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.grantContainerApiPrivilegesWithGrantOption = function(privileges, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillApiPrivileges(privileges, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _grant_api_privileges_with_grant_option(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.revokeContainerApiPrivileges = function(privileges, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillApiPrivileges(privileges, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _revoke_api_privileges(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult = (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.grantContainerSchemaPrivileges = function(privileges, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSchemaPrivileges(privileges, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _grant_schema_privileges(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult =  (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.revokeContainerSchemaPrivileges = function(privileges, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSchemaPrivileges(privileges, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _revoke_schema_privileges(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult =  (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.grantContainerSchemaRoles = function(roles, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSchemaRoles(roles, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _grant_schema_roles(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult =  (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.revokeContainerSchemaRoles = function(roles, call_params, externCB) {
        var tasks = [
            function(callback) { _create_temp_tables(target, logger, callback); },
            function(callback) { target.tempTables.fillSchemaRoles(roles, callback); },
            function(callback) { target.tempTables.fillParameters(call_params, callback); },
            function(callback) { _revoke_schema_roles(target.connection, target.container, callback); }
        ];
        async.series(tasks, function(err, results) {
            if (err) {
                return externCB(err);
            }
            var lastResult =  (results.length > 0) ? results[results.length - 1] : results;
            if (logger) {
                logger(lastResult.MESSAGES);
            }
            return externCB(null, lastResult);
        });
    };

    this.close = function() {
        target.tempTables = null;
        target.connection.close();
    };

    this.info = function() {
        return target;
    };
};
