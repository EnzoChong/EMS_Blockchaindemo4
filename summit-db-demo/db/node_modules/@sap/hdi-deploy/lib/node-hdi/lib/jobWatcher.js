'use strict';

var async = require('async');

// listener(err, result)
exports.waitForCompletion = function(connection, container, results, listener) {
    var row_id = -1;
    var request_id = results.REQUEST_ID;
    var maxSeverity = 'INFO';
    var messages = [];
    var jobs;
    var foundEndMessage = false;
    var jobEnded = false;

    var sql = [
        "DO BEGIN",
        "  DECLARE REQUEST_ID BIGINT = " + request_id + ";",
        "  DECLARE ROW_ID BIGINT = " + row_id + ";",
        "  SELECT * FROM " + container.toUpperCase() + "#DI.M_MESSAGES WHERE REQUEST_ID = :REQUEST_ID AND ROW_ID > :ROW_ID ORDER BY ROW_ID;",
        "  SELECT COUNT(*) FROM " + container.toUpperCase() + "#DI.M_JOBS WHERE REQUEST_ID = :REQUEST_ID ",
        "    AND IS_INTERNAL_CONNECTION_ACTIVE != 'FALSE' AND STATUS IN ('Committed','Simulated');",
        "END"
    ].join("\n");

    function setSeverity(severity) {
        if (maxSeverity !== 'ERROR') {
            if (severity !== 'INFO') {
                maxSeverity = severity;
            } // else: severity === 'INFO', no need to change anything
        }
    }

    function errorFilter(err) {
        if (err.message !== 'continue') {
            return false;
        }
        if (Array.isArray(messages) && messages.length > 0) {
            row_id = messages[messages.length - 1].ROW_ID;
            foundEndMessage = (messages[messages.length - 1].MESSAGE === 'END');
            messages.forEach(function(msg) { setSeverity(msg.SEVERITY); });
            listener(null, messages);
        }
        if (foundEndMessage || jobEnded) {
            listener(null, 'END-OF-JOB: max. severity: ' + maxSeverity); // emit END-OF-JOB message
            return false; // don't continue
        }
        if (typeof jobs !== 'undefined' && jobs['COUNT (*)'] === 0) {
            jobEnded = true; // but allow one last retry
        }
        return true;
    }

    //fetchMessages(connection, container, request_id, row_id, results, callback, listener);
    function fetchMessages(asyncCB /*, results*/) {
        connection.prepare(sql, function(err, stmt) {
            if (err) {
                console.log("err: ", err);
                return asyncCB(err);
            }
            stmt.exec({}, function(err, scalarParams, current_messages, current_jobs) {
                if (err) {
                    console.log("err2: ", err);
                    return asyncCB(err);
                }
                messages = current_messages;
                jobs = current_jobs;
                return asyncCB(new Error('continue'));
            });
        });
    }

    async.retry({errorFilter: errorFilter}, fetchMessages, listener);
};
