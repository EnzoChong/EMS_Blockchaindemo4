/* jshint node: true */

'use strict';

var async = require('async'); // NOTE 'callback' is always the callback injected by async; 'loggerCB' is also used for positive feedback

// execute a simple statement without parameters and result set
function _execute_direct(connection, logger, sql, callback) {
    connection.exec(sql, function (err) {
        if (err) {
            return callback(err);
        }
        var result = 'OK: _execute_direct: ' + sql;
        return callback(null, result);
    });
}

// execute update/insert/upsert/... statement
function _execute_update(connection, logger, sql, params, callback) {
    connection.prepare(sql, function(err, stmt) {
        if (err) {
            return callback(err);
        }
        stmt.exec(params, function(err, affectedRows) {
            if (err) {
                return callback(err);
            }
            var result = 'OK: _execute_update: ' + sql + ', Affected rows: ' + affectedRows;
            callback(null, result);
        });
    });
}

// Multimap parameters, e.g., {"key1" : ["value1", "value2"], ... } have to be flattened
// into an array of arrays, e.g. [ ["key1", "value1"], ["key1", "value2"], ...],
// before they can be inserted into the DB
/* TODO ES6
function _flatten_parameters(parameters) {
    return Object.keys(parameters)
                 .map(key => { var v = parameters[key], o = [];
                               return Array.isArray(v) ? v.map(vv => {o = [key, vv]; return o;})
                                                       : (o = [key, v], [o]); })
                 .reduce((prev, curr) => prev.concat(curr), []);
}
*/
function _flatten_parameters(parameters) {
    function unpack(key, array) {
        var newArray = [];
        array.forEach(function(value) {
            newArray.push([key, value]);
        });
        return newArray;
    }

    var flatParams = [];
    Object.keys(parameters).forEach(function(key) {
        var v = parameters[key];
        if (Array.isArray(v)) {
            flatParams = flatParams.concat( unpack(key, v) );
        } else {
            flatParams.push([key, v]);
        }
    });
    return flatParams;
}

// transform {"path1" : {"key1" : "value1", "key2" : "value2"}, ...}
// into an array of arrays [["path1", "key1", "value1"], ["path1", "key2", "value2"], ...]
/* TOD ES6
function _flatten_path_parameters(parameters) {
    return Object.keys(parameters)
                 .map(path => _flatten_parameters(parameters[path]).map(arr => { arr.unshift(path); return arr; }))
                 .reduce((prev, curr) => prev.concat(curr), []);
}
*/
function _flatten_path_parameters(parameters) {
    var flatParams = [];

    Object.keys(parameters).forEach(function(path) {
        var newArray = _flatten_parameters(parameters[path]);
        newArray.forEach(function(value) {
            value.unshift(path);
            flatParams.push(value);
        });
    });
    return flatParams;
}

function _quoted_sql_identifier(identifier) {
    return '"' + identifier.replace(/\"/g, '""') + '"';
}

function _prefix(container, table) {
    return _quoted_sql_identifier(container + '#DI') + '.' + table;
}

// create the necessary temporary tables for parameters etc.
function _create_SYS_DI_helper_tables(connection, logger, callback) {
    var tables = [ { name: "_SYS_DI.#PARAMETERS",        type: "_SYS_DI.TT_PARAMETERS" },
                   { name: "_SYS_DI.#CONFIG_PARAMETERS", type: "_SYS_DI.TT_PARAMETERS" } ];

    var tasks = [];
    tables.forEach(function(table) {
        var createStmt = 'CREATE LOCAL TEMPORARY COLUMN TABLE ' + table.name + ' LIKE ' + table.type;
        tasks.push( function(asyncCB) { _execute_direct(connection, logger, createStmt, asyncCB); } );
    });

    async.series(tasks, function(err, results) {
        if (err) {
            return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

function _create_helper_tables(connection, container, logger, callback) {
    var tables = [ { name: "#PARAMETERS",        type: "_SYS_DI.TT_PARAMETERS" },
                   { name: "#CONFIG_PARAMETERS", type: "_SYS_DI.TT_PARAMETERS" },
                   { name: "#PATHS",             type: "_SYS_DI.TT_FILESFOLDERS" },
                   { name: "#DEPLOY_PATHS",      type: "_SYS_DI.TT_FILESFOLDERS" },
                   { name: "#UNDEPLOY_PATHS",    type: "_SYS_DI.TT_FILESFOLDERS" },
                   { name: "#PATH_PARAMETERS",   type: "_SYS_DI.TT_FILESFOLDERS_PARAMETERS" },
                   { name: "#PATHS_CONTENT",     type: "_SYS_DI.TT_FILESFOLDERS_CONTENT" },
                   { name: "#API_PRIVILEGES",    type: "_SYS_DI.TT_API_PRIVILEGES "},
                   { name: "#SCHEMA_PRIVILEGES", type: "_SYS_DI.TT_SCHEMA_PRIVILEGES"},
                   { name: "#SCHEMA_ROLES",      type: "_SYS_DI.TT_SCHEMA_ROLES"},
                   { name: "#LIBRARY_CONFIG",    type: "_SYS_DI.TT_LIBRARY_CONFIGURATION"} ];

    var tasks = [];
    tables.forEach(function(table) {
        var createStmt = 'CREATE LOCAL TEMPORARY COLUMN TABLE ' + _prefix(container, table.name) + ' LIKE ' + table.type;
        tasks.push( function(asyncCB) { _execute_direct(connection, logger, createStmt, asyncCB); } );
    });

    async.series(tasks, function(err, results) {
        if (err) {
            return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

// fill the #PARAMETERS table
// when called with an empty object, the #PARAMETERS table is only truncated
function _fill_parameters(connection, logger, table, parameters, callback) {
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (typeof parameters !== 'object') {
        return callback(new Error('JS object required to fill temporary table "' + table + '".'));
    } else {
        if (Object.keys(parameters).length > 0) {
            var insertParameters = _flatten_parameters(parameters);
            var insertStmt = 'INSERT INTO ' + table + ' (KEY, VALUE) VALUES (?, ?)';
            tasks.push( function(asyncCB) { _execute_update(connection, logger, insertStmt, insertParameters, asyncCB); } );
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
            return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

// fill one of the #*PATHS table (for deleting files and folders, makes and status retrieval)
// when called with an empty array of paths, the table is only truncated
function _fill_paths(connection, logger, paths, table, callback) {
    table = table || '#PATHS';
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (!Array.isArray(paths)) {
        return callback(new Error('"paths" must be an array'));
    } else {
        if (paths.length > 0) {
            /* TODO ES6
            var insertParameters = paths.map(path => [path]);
            */
            var insertParameters = [];
            paths.forEach(function(path) { insertParameters.push([path]); });
            var insertStmt = 'INSERT INTO ' + table + ' (PATH) VALUES (?)';
            tasks.push( function(asyncCB) { _execute_update(connection, logger, insertStmt, insertParameters, asyncCB); } );
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
           return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

// fill the #PATHS_CONTENT table (for writing files and folders)
// files must be an array of 2-element arrays
function _fill_paths_and_content(connection, logger, files, table, callback) {
    table = table || '#PATHS_CONTENT';
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { return _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (!Array.isArray(files)) {
        return callback(new Error('"files" must be an array (of arrays)'));
    }

    if (files.length > 0) {
        var insertStmt = 'INSERT INTO ' + table + ' (PATH, CONTENT) VALUES (?, ?)';
        tasks.push( function(asyncCB) { return _execute_update(connection, logger, insertStmt, files, asyncCB); } );
    } else {
        if (logger) {
            logger('_fill_paths_and_content: empty files array.');
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
            return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        return callback(null, results);
    });
}

// fill the #PATH_PARAMETERS table
// parameters must be an object like { path : { key : value, key : value ,... }, ...}
function _fill_path_parameters(connection, logger, parameters, table, callback) {
    table = table || '#PATH_PARAMETERS';
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (typeof parameters !== 'object') {
        return callback(new Error('JS object required to fill temporary table "#PATH_PARAMETERS"'));
    } else {
        if (Object.keys(parameters).length > 0) {
            var insertParameters = _flatten_path_parameters(parameters);
            var insertStmt = 'INSERT INTO ' + table + ' (PATH, KEY, VALUE) VALUES (?, ?, ?)';
            tasks.push( function(asyncCB) { _execute_update(connection, logger, insertStmt, insertParameters, asyncCB); } );
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
           return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

// fill the #API_PRIVILEGES table
// privileges must be an array of 4-tuples
function _fill_api_privileges(connection, logger, privileges, table, callback) {
    table = table || '#API_PRIVILEGES';
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (!Array.isArray(privileges)) {
        return callback(new Error('"privileges" must be an array (of arrays)'));
    }

    if (privileges.length > 0) {
        var insertStmt = 'INSERT INTO ' + table + ' (PRIVILEGE_NAME, OBJECT_NAME, PRINCIPAL_SCHEMA_NAME, PRINCIPAL_NAME) VALUES (?, ?, ?, ?)';
        tasks.push( function(asyncCB) { return _execute_update(connection, logger, insertStmt, privileges, asyncCB); } );
    } else {
        if (logger) {
            logger('_fill_api_privileges: empty privilege array.');
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
           return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

function _fill_schema_privileges(connection, logger, privileges, table, callback) {
    table = table || '#SCHEMA_PRIVILEGES';
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (!Array.isArray(privileges)) {
        return callback(new Error('"privileges" must be an array (of arrays)'));
    }

    if (privileges.length > 0) {
        var insertStmt = 'INSERT INTO ' + table + ' (PRIVILEGE_NAME, PRINCIPAL_SCHEMA_NAME, PRINCIPAL_NAME) VALUES (?, ?, ?)';
        tasks.push( function(asyncCB) { return _execute_update(connection, logger, insertStmt, privileges, asyncCB); } );
    } else {
        if (logger) {
            logger('_fill_schema_privileges: empty privilege array.');
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
           return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

function _fill_schema_roles(connection, logger, roles, table, callback) {
    table = table || '#SCHEMA_ROLES';
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (!Array.isArray(roles)) {
        return callback(new Error('"roles" must be an array (of arrays)'));
    }

    if (roles.length > 0) {
        var insertStmt = 'INSERT INTO ' + table + ' (ROLE_NAME, PRINCIPAL_SCHEMA_NAME, PRINCIPAL_NAME) VALUES (?, ?, ?)';
        tasks.push( function(asyncCB) { return _execute_update(connection, logger, insertStmt, roles, asyncCB); } );
    } else {
        if (logger) {
            logger('_fill_schema_roles: empty roles array.');
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
           return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

// fill the #LIBRARY_CONFIG table
// libconfig must be an array of [action, library_name] tuples
function _fill_library_config(connection, logger, libconfig, table, callback) {
    table = table || '#LIBRARY_CONFIG';
    var tasks = [];

    var truncateStmt = 'TRUNCATE TABLE ' + table;
    tasks.push( function(asyncCB) { _execute_direct(connection, logger, truncateStmt, asyncCB); } );

    if (!Array.isArray(libconfig)) {
        return callback(new Error('"libconfig" must be an array (of arrays)'));
    }

    if (libconfig.length > 0) {
        var insertStmt = 'INSERT INTO ' + table + ' (ACTION, LIBRARY_NAME) VALUES (?, ?)';
        tasks.push( function(asyncCB) { return _execute_update(connection, logger, insertStmt, libconfig, asyncCB); } );
    } else {
        if (logger) {
            logger('_fill_library_config: empty libconfig array.');
        }
    }

    async.series(tasks, function(err, results) {
        if (err) {
           return callback(err);
        }
        if (logger) {
            logger(results.join('\n'));
        }
        callback(null, results);
    });
}

// hdb: open connection to a HANA database
module.exports = function(hdb, container, loggerCB) {
    var connection = hdb;
    var logger = loggerCB;

    this.createSysDi = function(callback) {
        return _create_SYS_DI_helper_tables(connection, logger, callback);
    };

    this.create = function(container, callback) {
        return _create_helper_tables(connection, container, logger, callback);
    };

    this.fillSysDiParameters = function(parameters, callback) {
        return _fill_parameters(connection, logger, '_SYS_DI.#PARAMETERS', parameters, callback);
    };

    this.fillSysDiConfigParameters = function(parameters, callback) {
        return _fill_parameters(connection, logger, '_SYS_DI.#CONFIG_PARAMETERS', parameters, callback);
    };

    this.fillParameters = function(parameters, callback) {
        return _fill_parameters(connection, logger, _prefix(container, '#PARAMETERS'), parameters, callback);
    };

    this.fillConfigParameters = function(parameters, callback) {
        return _fill_parameters(connection, logger, _prefix(container, '#CONFIG_PARAMETERS'), parameters, callback);
    };

    this.fillPaths = function(paths, table, callback) {
        return _fill_paths(connection, logger, paths, _prefix(container, table), callback);
    };

    this.fillPathsAndContent = function(files, callback) {
        return _fill_paths_and_content(connection, logger, files, _prefix(container, '#PATHS_CONTENT'), callback);
    };

    this.fillPathParameters = function(parameters, callback) {
        return _fill_path_parameters(connection, logger, parameters, _prefix(container, '#PATH_PARAMETERS'),  callback);
    };

    this.fillApiPrivileges = function(privileges, callback) {
        return  _fill_api_privileges(connection, logger, privileges, _prefix(container, '#API_PRIVILEGES'),  callback);
    };

    this.fillSchemaPrivileges = function(privileges, callback) {
        return  _fill_schema_privileges(connection, logger, privileges, _prefix(container, '#SCHEMA_PRIVILEGES'), callback);
    };

    this.fillSchemaRoles = function(roles, callback) {
        return  _fill_schema_roles(connection, logger, roles, _prefix(container, '#SCHEMA_ROLES'), callback);
    };

    this.fillLibraryConfig = function (libconfig, callback) {
        return _fill_library_config(connection, logger, libconfig, _prefix(container, '#LIBRARY_CONFIG'), callback);
    };
};
